/**
 * Codebase index shared algorithms — pure functions for module classification,
 * import extraction, dependency resolution, and prompt formatting.
 *
 * No filesystem, git, or child_process I/O. The I/O-heavy functions
 * (buildCodebaseIndex, refreshCodebaseIndex, hasStructuralChanges) live
 * in ./index.ts and import these pure algorithms.
 */

import * as path from 'node:path';

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface CodebaseIndex {
  built_at: string;
  modules: ModuleEntry[];
  dependency_edges: Record<string, string[]>; // module → modules it imports from
  untested_modules: string[];
  large_files: LargeFileEntry[];              // >300 LOC
  entrypoints: string[];
  /** mtimes of files sampled for import scanning — used for change detection. Not included in prompt. */
  sampled_file_mtimes: Record<string, number>;
}

export type ClassificationConfidence = 'high' | 'medium' | 'low';

export interface ModuleEntry {
  path: string;       // "src/services"
  file_count: number;
  production_file_count: number; // excludes test/story/fixture files within mixed modules
  purpose: string;    // "api"|"services"|"tests"|"ui"|"utils"|"config"|"fixtures"|"docs"|"scripts"|"generated"|"unknown"
  production: boolean; // false for tests, config, fixtures, docs, scripts, generated, etc.
  /** How confident the classifier is. 'low' means no signals matched — assumed production. */
  classification_confidence: ClassificationConfidence;
}

export interface LargeFileEntry {
  path: string;
  lines: number;
}

export interface ClassifyResult {
  purpose: string;
  production: boolean;
  productionFileCount: number;
  confidence: ClassificationConfidence;
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

export const SOURCE_EXTENSIONS = new Set([
  '.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs',
  '.py',
  '.rs',
  '.go',
  '.rb',
  '.java', '.kt', '.kts', '.scala',
  '.cs',
  '.ex', '.exs',
  '.php',
  '.swift',
  '.dart',
  '.c', '.cpp', '.h', '.hpp',
  '.hs',
  '.lua',
  '.zig',
]);

/** Directory-name hint — fast path when the name is unambiguous. */
export const PURPOSE_HINT: Record<string, string> = {
  api: 'api', apis: 'api', routes: 'api', handlers: 'api',
  controllers: 'api', endpoints: 'api',
  services: 'services', service: 'services', lib: 'services', core: 'services',
  ui: 'ui', components: 'ui', views: 'ui', pages: 'ui', screens: 'ui',
  utils: 'utils', util: 'utils', helpers: 'utils', shared: 'utils', common: 'utils',
};

export const NON_PRODUCTION_PURPOSES = new Set([
  'tests', 'config', 'fixtures', 'docs', 'scripts', 'generated',
]);

/** Chunk size for prompt rendering. */
export const CHUNK_SIZE = 15;

// ---------------------------------------------------------------------------
// Regex patterns
// ---------------------------------------------------------------------------

/** File-name patterns that indicate non-production files (even within production modules). */
export const NON_PROD_FILE_RE = /\.(test|spec|e2e|integration|stories|story)\./i;

/**
 * Polyglot test-content patterns — matches test framework calls across languages.
 */
export const TEST_CONTENT_RE = new RegExp([
  /\b(describe|it|test|expect|assert|beforeEach|afterEach|beforeAll|afterAll|jest|vitest|mocha|chai)\s*[.(]/.source,
  /\b(pytest|unittest|def test_)\b/.source,
  /#\[(test|cfg\(test\))\]/.source,
  /\bfunc\s+Test[A-Z]/.source,
  /@(Test|TestMethod)\b/.source,
  /\b(RSpec\.|Minitest|should\s)/.source,
  /\b(ExUnit|use ExUnit)/.source,
  /\b(PHPUnit|->assert[A-Z])/.source,
  /\b(XCTestCase|func\s+test[A-Z])/.source,
].join('|'));

export const GENERATED_RE = /(@generated|DO NOT EDIT|auto-generated|THIS FILE IS GENERATED|generated by)/i;
export const CONFIG_CONTENT_RE = /\b(module\.exports|export default|defineConfig|createConfig)\b/;
export const CONFIG_EXT_RE = /\.(json|ya?ml|toml|ini|env)$/i;
export const FIXTURE_CONTENT_RE = /\b(mock[A-Z]\w*|fake[A-Z]\w*|stub[A-Z]\w*|fixture[A-Z]\w*)\s*[=:]|\bexport\s+(const|function)\s+(mock|fake|stub|fixture|seed|sample)/i;

// JS/TS: import ... from '...' or require('...')
export const JS_IMPORT_RE = /(?:import\s+.*?\s+from\s+['"]([^'"]+)['"]|require\s*\(\s*['"]([^'"]+)['"]\s*\))/g;
// Python: from X import ... or import X
export const PY_IMPORT_RE = /(?:from\s+([\w.]+)\s+import|^import\s+([\w.]+))/gm;
// Go: import "..."
export const GO_IMPORT_RE = /import\s+"([^"]+)"/g;

// ---------------------------------------------------------------------------
// Pure functions
// ---------------------------------------------------------------------------

/** Map directory name to a purpose hint. Returns 'unknown' if no match. */
export function purposeHintFromDirName(dirName: string): string {
  return PURPOSE_HINT[dirName.toLowerCase()] ?? 'unknown';
}

/**
 * Pick up to `count` items, evenly spaced across the array.
 * Avoids alphabetical bias of always sampling the first N.
 */
export function sampleEvenly<T>(arr: T[], count: number): T[] {
  if (arr.length <= count) return arr;
  const step = arr.length / count;
  const result: T[] = [];
  for (let i = 0; i < count; i++) {
    result.push(arr[Math.floor(i * step)]);
  }
  return result;
}

/** Count non-production files by name pattern within a file list. */
export function countNonProdFiles(fileNames: string[]): number {
  return fileNames.filter(f => NON_PROD_FILE_RE.test(f)).length;
}

/**
 * Classify a module by analyzing its file names and content snippets.
 *
 * Uses file-name patterns (checked against ALL files — cheap string matching)
 * and content analysis (sampled snippets from evenly-distributed files).
 *
 * Thresholds use both ratio AND absolute count to avoid misclassifying
 * large mixed modules (40% test in a 500-file module ≠ production).
 */
export function classifyModule(
  dirName: string,
  allFileNames: string[],
  contentSnippets: string[],
  totalFileCount: number,
): ClassifyResult {
  const nonProdFiles = countNonProdFiles(allFileNames);
  const nonProdRatio = allFileNames.length > 0 ? nonProdFiles / allFileNames.length : 0;

  // 1. Majority of files are test/story files → whole module is non-production
  if (nonProdRatio > 0.5 || (nonProdFiles >= 10 && nonProdRatio > 0.4)) {
    return { purpose: 'tests', production: false, productionFileCount: 0, confidence: 'high' };
  }

  // 2. Check content signals across sampled snippets
  let testHits = 0;
  let generatedHits = 0;
  let configHits = 0;
  let fixtureHits = 0;
  const total = contentSnippets.length || 1;

  for (const snippet of contentSnippets) {
    if (TEST_CONTENT_RE.test(snippet)) testHits++;
    if (GENERATED_RE.test(snippet)) generatedHits++;
    if (CONFIG_CONTENT_RE.test(snippet)) configHits++;
    if (FIXTURE_CONTENT_RE.test(snippet)) fixtureHits++;
  }

  if (generatedHits / total > 0.5) {
    return { purpose: 'generated', production: false, productionFileCount: 0, confidence: 'high' };
  }

  if (testHits / total > 0.5) {
    return { purpose: 'tests', production: false, productionFileCount: 0, confidence: 'high' };
  }

  if (fixtureHits / total > 0.5) {
    return { purpose: 'fixtures', production: false, productionFileCount: 0, confidence: 'high' };
  }

  // 3. Config: mostly config-extension files or config content
  const configFileCount = allFileNames.filter(f => CONFIG_EXT_RE.test(f)).length;
  const configFileRatio = allFileNames.length > 0 ? configFileCount / allFileNames.length : 0;
  if (configFileRatio > 0.5 || (configHits / total > 0.5 && configFileRatio > 0.3)) {
    return { purpose: 'config', production: false, productionFileCount: 0, confidence: 'high' };
  }

  // 4. Production module — subtract non-prod files from count
  const hint = purposeHintFromDirName(dirName);
  const prodCount = Math.max(0, totalFileCount - nonProdFiles);

  const hasContentSignals = contentSnippets.length > 0 && (testHits > 0 || generatedHits > 0 || configHits > 0 || fixtureHits > 0);
  const hasHint = hint !== 'unknown';
  const confidence: ClassificationConfidence =
    hasHint ? 'high' :
    hasContentSignals ? 'medium' :
    'low';

  return { purpose: hint, production: true, productionFileCount: prodCount, confidence };
}

/**
 * Extract import specifiers from file content using polyglot regex patterns.
 * Supports JS/TS, Python, and Go.
 */
export function extractImports(content: string, filePath: string): string[] {
  const ext = path.extname(filePath);
  const imports: string[] = [];

  if (ext === '.ts' || ext === '.tsx' || ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {
    for (const m of content.matchAll(new RegExp(JS_IMPORT_RE.source, 'g'))) {
      const spec = m[1] ?? m[2];
      if (spec) imports.push(spec);
    }
  } else if (ext === '.py') {
    for (const m of content.matchAll(new RegExp(PY_IMPORT_RE.source, 'gm'))) {
      const spec = m[1] ?? m[2];
      if (spec) imports.push(spec);
    }
  } else if (ext === '.go') {
    for (const m of content.matchAll(new RegExp(GO_IMPORT_RE.source, 'g'))) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.rs') {
    // Rust: use crate::..., use std::..., use super::...
    for (const m of content.matchAll(/\buse\s+((?:crate|super|self|std)\b[\w:]+)/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.java' || ext === '.kt' || ext === '.kts' || ext === '.scala') {
    // Java/Kotlin/Scala: import package.Class
    for (const m of content.matchAll(/\bimport\s+([\w.]+)/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.rb') {
    // Ruby: require 'lib' or require_relative 'path'
    for (const m of content.matchAll(/\brequire(?:_relative)?\s+['"]([^'"]+)['"]/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.cs') {
    // C#: using Namespace;
    for (const m of content.matchAll(/\busing\s+([\w.]+)\s*;/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.swift') {
    // Swift: import Module
    for (const m of content.matchAll(/\bimport\s+(\w+)/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.ex' || ext === '.exs') {
    // Elixir: alias/import/use Module
    for (const m of content.matchAll(/\b(?:alias|import|use)\s+([\w.]+)/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.php') {
    // PHP: use Namespace\Class;
    for (const m of content.matchAll(/\buse\s+([\w\\]+)/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.dart') {
    // Dart: import 'package:...';
    for (const m of content.matchAll(/\bimport\s+['"]([^'"]+)['"]/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.c' || ext === '.cpp' || ext === '.h' || ext === '.hpp') {
    // C/C++: #include "local.h" (skip <system.h>)
    for (const m of content.matchAll(/#include\s+"([^"]+)"/g)) {
      if (m[1]) imports.push(m[1]);
    }
  } else if (ext === '.hs') {
    // Haskell: import Module.Name
    // eslint-disable-next-line security/detect-unsafe-regex
    for (const m of content.matchAll(/\bimport\s+(?:qualified\s+)?([\w.]+)/g)) {
      if (m[1]) imports.push(m[1]);
    }
  }

  return imports;
}

/**
 * Resolve a relative import specifier to a module path relative to projectRoot.
 * Returns null for non-relative (package) imports.
 */
export function resolveImportToModule(
  specifier: string,
  sourceFile: string,
  projectRoot: string,
  modulePaths: string[],
): string | null {
  if (!specifier.startsWith('.')) return null;

  const sourceDir = path.dirname(sourceFile);
  const resolved = path.resolve(sourceDir, specifier);
  const relative = path.relative(projectRoot, resolved);

  for (const mod of modulePaths) {
    if (relative === mod || relative.startsWith(mod + '/') || relative.startsWith(mod + path.sep)) {
      return mod;
    }
  }
  return null;
}

/**
 * Format a codebase index for injection into a scout prompt.
 *
 * Chunks modules (15 per chunk) and rotates by cycle number so all modules
 * get exposure over multiple cycles. Includes untested modules, hotspots,
 * and entrypoints.
 */
export function formatIndexForPrompt(index: CodebaseIndex, scoutCycle: number): string {
  const { modules, dependency_edges, untested_modules, large_files, entrypoints } = index;

  if (modules.length === 0) {
    return '## Codebase Structure\n\nNo modules detected.';
  }

  const totalChunks = Math.max(1, Math.ceil(modules.length / CHUNK_SIZE));
  const chunkIndex = scoutCycle % totalChunks;
  const offset = chunkIndex * CHUNK_SIZE;
  const focusModules = modules.slice(offset, offset + CHUNK_SIZE);
  const otherModules = modules.filter((_, i) => i < offset || i >= offset + CHUNK_SIZE);

  const parts: string[] = [];

  parts.push(`## Codebase Structure (chunk ${chunkIndex + 1}/${totalChunks})`);
  parts.push('');
  parts.push('### Modules in Focus This Cycle');

  for (const mod of focusModules) {
    const deps = dependency_edges[mod.path];
    const depStr = deps ? ` → imports: ${deps.join(', ')}` : '';
    parts.push(`${mod.path}/ — ${mod.file_count} files (${mod.purpose})${depStr}`);
  }

  if (otherModules.length > 0) {
    parts.push('');
    parts.push('### Other Modules (not in focus — available for future cycles)');
    parts.push(otherModules.map(m => m.path + '/').join(', '));
  }

  if (untested_modules.length > 0) {
    parts.push('');
    parts.push('### Untested Modules (context only — do NOT prioritize writing tests for these)');
    parts.push(untested_modules.map(m => m + '/').join(', '));
  }

  if (large_files.length > 0) {
    parts.push('');
    parts.push('### Complexity Hotspots (>300 LOC)');
    parts.push(large_files.map(f => `${f.path} (${f.lines})`).join(', '));
  }

  if (entrypoints.length > 0) {
    parts.push('');
    parts.push('### Entrypoints');
    parts.push(entrypoints.join(', '));
  }

  return parts.join('\n');
}
